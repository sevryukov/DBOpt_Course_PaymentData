# Задачи I уровня

В данном разделе стоит задача реализации индексов, повышающих производительность операций вставки и изменения платежей без модификации программных компонент. 
В результате, был разработан код транзакции для операции вставки данных в таблицу dbo.Payment, а также код транзакции для операции изменения данных в таблице dbo.Payment, некластеризованные индексы для полей таблиц, которые использовались в триггере T_Payment_AI, срабатывающим после вставки или изменения платежа, в функциях dbo.F_CalculatePaymentParticipantBalance, dbo.F_CalculateBalanceByMaterial, dbo.F_CalculateBalanceByWork, dbo.F_CalculateProjectBalance. 
Триггер работает следующим образом:
* Вызов триггера при вставке/изменении платежа в таблицу Payment;

* Обновление баланса у новых участников (плательщик - Payer и получатель - Payee) - функция dbo.F_CalculatePaymentParticipantBalance;

* Обновление баланса у старых участников плательщик - Payer и получатель - Payee) - функция dbo.F_CalculatePaymentParticipantBalance;

* Обновление баланса у новых объектов - функции dbo.F_CalculateBalanceByMaterial, dbo.F_CalculateBalanceByWork, dbo.F_CalculateProjectBalance;

* Обновление баланса у старых объектов - функции dbo.F_CalculateBalanceByMaterial, dbo.F_CalculateBalanceByWork, dbo.F_CalculateProjectBalance;

Было принято решение использовать некластеризованный индекс, так как, в отличие от кластеризованного индекса, листья некластеризованного индекса содержат только необходимые столбцы, а также указатель на строки с реальными данными в таблице, а также потому, что для одной таблицы можно определить более одного некластеризованного индекса, что позволяет добавить индекс только для необходимых атрибутов, использующихся в функциях, перечисленных выше.

## Основные тесты
В качестве метрики использовалось среднее время, затраченное на выполнение одной транзакции, подсчеты велись с помощью программного обеспечения SQLQueryStress. Было создано подключение к базе данных PaymentData и проведены тесты для операций вставки(100, 400 и 1000), а также для операций изменения(100, 400). Результаты представлены на рисунках ниже. 
Далее, для реализации индексов был рассмотрен триггер T_Payment_AI. Если используются поля, в которых отсутствует индекс, то его, в таком случае, необходимо создать. 
При срабатывании данного триггера вызываются функции:
* dbo.F_CalculatePaymentParticipantBalance – необходимо добавить индекс для полей PaymentCategory.NotInPaymentParticipantProfit, PaymentCategory.Name, AccountType.Name;
* dbo.F_CalculateBalanceByMaterial – необходимо добавить индекс для полей  Supplier.ProfitByMaterialAsPayer, Supplier.ProfitByMaterialAsPayee, AccountType.Name, PaymentCategory.Name, PaymentCategory.ProfitByMaterial, PaymentCategory.CostByMaterial;
* dbo.F_CalculateBalanceByWork – необходимо добавить индекс для полей AccountType.Name, PaymentCategory.Name;
* dbo.F_CalculateProjectBalance – необходимо добавить индекс для полей PaymentCategory.Name;

В результате, были созданы следующие индексы: PCProfByMatInd, PCCostByMatInd, PCNPayPartInd, PCNameInd, ATNameInd, SuppProfByMatPayerInd, SuppProfByMatPayeeInd. Код представлен на рисунке ниже.
Далее были заново проведены тесты для операций вставки данных в таблицу и изменений данных в таблице. Результаты представлены на рисунках ниже.
Более детально результаты среднего времени на исполнение одной транзакции представлены в таблице ниже.

|Название, количество итераций|Время перед добавлением индексов, с|Время после добавления индексов, с|
|:---------------------------:|:---------------------------------:|:--------------------------------:|
|Операция вставки             |                                   |                                  |
|100                          |1,3778                             |1,4129                            |
|400                          |1,2484                             |1,0496                            |
|1000                         |1,3476                             |1,0024                            |
|Операция изменения           |                                   |                                  |
|100                          |8,4455                             |8,1003                            |
|400                          |7,6453                             |6,8851                            |


В результате, можно заметить, что при меньшем количестве операций операция вставки работает дольше, время увеличилось на 2.5%, возможно, данный феномен связан с техническим оснащением. Далее, при 400 итерациях прирост скорости операции вставки составляет около 16%, а при 1000 итерациях около 26%. Если говорить об операции изменения данных, то при 100 итерациях прирост составляет около 4%, а при 400 итерациях около 10%.  Средний прирост для операции вставки данных в таблицу dbo.Payment, таким образом, составляет порядка 13%, а для операции изменения данных средний прирост составляет порядка 7%.
## Тесты с различными индексами
* Были проведены тесты при добавлении только одного/некоторых из индексов. Сначала было проведено тестирование на вставку данных без индексов. Результаты представлены на рисунках ниже.
* Было принято решение вставить индекс в один столбец, AccountType.Name, так как он используется в большинстве функций. 
* Было принято решение вставить индекс в один столбец, PaymentCategory.Name, так как он также часто используется используется в функциях. 
* Было принято решение вставить индекс во все столбцы таблицы PaymentCategory, которые используются в функциях. 
* Было принято решение вставить индекс во все столбцы таблицы Supplier, которые используются в функциях. 
* Была проведена проверка результатов при добавлении всех индексов во все таблицы, использующихся в функциях.
* Было принято решение проверить результаты при добавлении индексов в столбцы таблицы Supplier и столбец dbo.Project.Client, потому что сначала при вставке данных идет перерасчет балансов в таблице PaymentParticipant, а потом в таблице Project, в результате Project join’ится с другими таблицами и в таблице Project содержится много записей.

После чего, аналогичные тесты были проведены для операции изменения данных в таблице Payment. 
Ниже приведена таблица с результатами сравнения и изменением среднего времени на одну транзакцию при введении отдельных некластеризованных индексов по сравнению с отсутствием некластеризованных индексов

|Название, количество итераций|Время перед добавлением индексов, с|Время после добавления индексов, с|Изменение,%|
|:---------------------------:|:---------------------------------:|:--------------------------------:|:---------:|
|Операция вставки||Индексы для AccountType.Name|Среднее 7,267788606|
|100|1,0997|1,0550|4,06474493|
|400|1,1096|0,9937|10,44520548|
|1000|1,0722|0,9940|7,293415408|
|Операция вставки||Индексы для PaymentCategory.Name|Среднее 7,439877354|
|100|1,0997|1,0171|7,511139402|
|400|1,1096|0,9843|11,29235761|
|1000|1,0722|1,0345|3,516135049|
|Операция вставки||Индексы для PaymentCategory.Name, PaymentCategory.ProfitByMaterial, PaymentCategory.CostByMaterial|Среднее 4,898416171|
|100|1,0997|1,0711|2,600709284|
|400|1,1096|1,0496|5,407354001|
|1000|1,0722|1,0005|6,687185227|
|Операция вставки||Индексы для Supplier.ProfitByMaterialAsPayer, Supplier.ProfitByMaterialAsPayee|Среднее 7,128999743|
|100|1,0997|0,9884|10,12094208|
|400|1,1096|0,9700|12,58111031|
|1000|1,0722|1,0863|-1,315053162|
|Операция вставки||Все индексы|Среднее 6,667627953|
|100|1,0997|1,0571|3,873783759|
|400|1,1096|0,9831|11,40050469|
|1000|1,0722|1,0215|4,728595411|
|Операция вставки||Индексы для Supplier.ProfitByMaterialAsPayer, Supplier.ProfitByMaterialAsPayee, Project.Client|Среднее 43,78456934|
|100|1,0997|0,6340|42,34791307|
|400|1,1096|0,5999|45,93547224|
|1000|1,0722|0,6104|43,0703227|
|Операция изменения данных||Индексы для AccountType.Name||
|100|6,7267|6,8263|-1,480666597|
|Операция изменения данных||Индексы для PaymentCategory.Name||
|100|6,7267|6,5444|2,710095589|
|Операция изменения данных||Индексы для PaymentCategory.Name, PaymentCategory.ProfitByMaterial, PaymentCategory.CostByMaterial||
|100|6,7267|6,5365|2,82753802|
|Операция изменения данных||Индексы для Supplier.ProfitByMaterialAsPayer, Supplier.ProfitByMaterialAsPayee||
|100|6,7267|6,6465|1,192263666|
|Операция изменения данных||Все индексы||
|100|6,7267|6,1643|8,36071179|
|Операция изменения данных||Индексы для Supplier.ProfitByMaterialAsPayer, Supplier.ProfitByMaterialAsPayee, Project.Client||
|100|6,7267|0,0114|99,83052611|

Исходя из представленной выше таблицы, использование всех индексов, использованных в первой части первого задания не дает самого большого прироста. 

Так, при операции вставки данных в таблицу Payment, в среднем, использование всех индексов дает прирост в примерно 6,7%, но если использовать некластеризованный индекс только для AccountType.Name, то прирост составит в среднем примерно 7,3%, если же  некластеризованный индекс только для PaymentCategory.Name, то прирост составит в среднем примерно 7,4%, если использовать некластеризованный индекс для столбцов Supplier.ProfitByMaterialAsPayer, Supplier.ProfitByMaterialAsPayee, то прирост составит в среднем примерно 7,1%. С другой стороны, использование всех некластеризованных индексов, применяемых в первой части,  одновременно дает больший прирост по сравнению с использованием некластеризованных индексов только для столбцов PaymentCategory.Name, PaymentCategory.ProfitByMaterial, PaymentCategory.CostByMaterial, при использовании которых прирост в среднем составляет примерно 4,9%. Если же, помимо некластеризованных индексов из первой части задания (Supplier.ProfitByMaterialAsPayer, Supplier.ProfitByMaterialAsPayee) использовать также некластеризованный индекс для Project.Client, то прирост в среднем составляет примерно 43,8%. 

Если говорить об операции изменения данных в таблице Update, то использование всех некластеризованных индексов из первой части задания, при 100 итерациях изменения данных строки, прирост составляет 8,4%, что гораздо выше в сравнении с другими вариантами. Единственное, если использовать некластеризованные индексы из первой части задания (Supplier.ProfitByMaterialAsPayer, Supplier.ProfitByMaterialAsPayee) использовать также некластеризованный индекс для Project.Client, то при 100 итерациях прирост составляет 99,8%. 



## Вывод

Большой прирост при применении комбинации индексов для Supplier.ProfitByMaterialAsPayer, Supplier.ProfitByMaterialAsPayee, Project.Client можно объяснить тем, что эти таблицы являются самыми часто используемыми при вызове триггеров при получении нового платежа, а также, потому что данные таблицы содержат самое большое количество строк.

В целом, правильное использование индексов действительно позволяет получить прирост производительности при операциях вставки и изменения платежа в таблице Payment. Исходя из полученных результатов, лучшим вариантом является использование индексов для Supplier.ProfitByMaterialAsPayer, Supplier.ProfitByMaterialAsPayee, Project.Client.
