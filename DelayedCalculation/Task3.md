### **Задача 1.**

_Реализовать предложенный сценарий отложенного вычисления._

В силу более легкой реализации для заданий 3 уровня был выбран второй сценарий с определением максимального количества вносимых необработанных записей. Выбор именно максимального количества значений позволяет избежать проблем с ручным вызовом переноса записей и перерасчета балансов. 
 
Реализация данного сценария  включала создание вспомогательной таблицы PaymentDelayed и триггера для нее, который после каждой вставки новой записи в данную таблицу вычисляет количество записей в таблице. При превышении максимального наперед заданного количества, происходит перенос всех новые записи в основную таблицу Payment. 
В качестве максимального допустимого размера таблицы PaymentDelayed было выбрано 100 записей, в силу того, что такое значение позволит посмотреть на производительность в разных соотношениях этого параметра c количеством вносимых записей. Помимо этого, такое значение кажется достаточно оптимальным с точки зрения частоты обновления записей.
Отдельное и более детальное исследование требуется, чтобы понять как происходит перенос записей при параллельном внесении записей (вопросы связанные с блокировками и целостностью данных). Здесь мы не будем уделять этим вопросам внимание. 

Для проверки корректности работы был использован слегка модифицированный тест из начальной части. Модификация заключалась в добавлении цикла, который позволял заполнить таблицу PaymentDelayed до размера необходимого для срабатывания переноса данных. 

Скрипт с реализацией данного сценария находится файле `Task3.sql` в папке `DelayedCalculation`.


### **Задача 2.**

_Дать оценку затрат на выполнение операций расчёта балансов в рамках транзакций создания и изменения платежа. Дать заключение о полученном росте производительности, если таковое будет наблюдаться._

Для оценки затрат на выполнение операций расчета балансов был использован тот же инструмент, что и в первой части SQLQueryStress. Для сравнения с изначальной реализацией были рассмотрены следующие условия

**По количеству вносимых записей:**
   - Количество вносимых записей меньше порогового значения (10 записей), что означает, что новые записи не будет перенесены в основную таблицу
   - Количество вносимых записей сопоставимо с пороговым значением (100 записей). Будет произведен только 1 перенос новых записей
   - Количество вносимых записей больше порогового значения (400 записей). Будет произведено множество переносов новый записей по группам. 

**По величине задержки после каждого запроса:**
   - Без задержки
   - С задержкой 100 миллисекунд


Сравнение в условиях задержки после каждой итерации рассматривается для того, чтобы удостовериться, что перенос данных действительно будет произведен несколько раз (то есть не произойдет так, что сначала во вспомогательную базу данных будут добавлены все 400 записей, а затем будет произведен только 1 перенос).

**Результаты:**

  **Без ожидания после каждой итерации**

    В Payment (изначальная реализация)
      1. 10 записей - 0.68сек
      2. 100 записей - 4.84сек
      3. 400 записей - 48.47сек
    
    В PaymentDelayed (предлагаемая реализация)
      1. 10 записей - 0.04сек
      2. 100 записей - 1.18сек
      3. 400 записей - 3.57сек

  **С ожиданием после каждого запроса (100 миллисекунд)**

Чтобы получить чистое время работы с учетом задержек, необходимо отнять 0.01 * n секунд от каждого результата. n - количество итераций.  
    
    В Payment (изначальная реализация)
      1. 10 записей - 3.94сек
      2. 100 записей - 41.95сек
      3. 400 записей - 3мин 37.93сек

    В PaymentDelayed (предлагаемая реализация)
      1. 10 записей - 2.2сек
      2. 100 записей - 12.15сек
      3. 400 записей - 48.21сек

Как видно по результатам рост производительности действительно имеет место быть, причем во всех случаях этот рост существенный. Сделать выводы о постоянной относительном приросте производительности сложно, так как полное время для изначального сценария растет нелинейно по отношению к количеству запросов, а для предлагаемого сценария уже прослеживается такая линейность. 
Если же сравнивать попарно для условий, когда количество вставленных записей равно 100 (то есть равно максимальному размеру достаточному, чтобы произошел один перерасчет балансов), то заметен прирост производительности **примерно в 4 раза**. Аналогично для 100 записей с задержками. 

### **Задача 3.**

_Дать оценку возникшим проблемам и недостаткам, сравнить их с оценками, сделанными при проектировании сценария оптимизации (указать, что сбылось, что неожиданно проявилось и т.д.)._

1. При реализации предложенного сценария возникли вопросы связанные с обновлением платежей. Сценарий со вспомогательной таблицей PaymentDelayed не предполагает возможности оптимизации производительности при обновлении записей. Обновление уже перенесенной записи приведет к вызову функции пересчета балансов.
В данном случае необходима более детальное погружение в предметную область, например, необходимо понять, как оператор может менять записи. Напомним, что оператор не имеет доступа к данным и не может их читать. 
*Реализация первого сценария с дополнительным столбцом в таблице Payment решала бы этот вопрос.*

2. Все также сохраняется вопрос об оптимальности выбора максимально размера вспомогательной таблицы. 

3. Необходимость занесения данных в таблицу PaymentDelayed может несколько запутать нового пользователя и ему придется разобраться в структуре базы данных. Однако этот недостаток можно устранить изолированием внутренностей от пользователей, предоставлением им понятного интерфейса для работа, либо же сменой названий таблиц.

### **Задача 4.**

_Дать заключение о преимуществах и недостатках выполненной оптимизации (превосходят ли полученные преимущества те недостатки, которые возникли после оптимизации)._

Выявленный прирост производительности, как нам кажется, существенно перевешивает выявленные недостатки. По крайней мере, возможность обновления старых записей все также сохранилась, и время обновления будет таким же, как и при изначальной реализации. 
