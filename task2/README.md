# Задачи II уровня

Был использован инструмент `Actual Execution Plan` в _SSMS_. Планы запросов сохранены в файлах формата `.sqlplan`.

Вставка записей в таблицу `Payment` занимает 8% от общих затрат в транзакции добавления платежа. В рамках этой операции самые большие затраты приходятся 
на вставку кластерного индекса в саму таблицу `Payment` (82%). Это связно с тем, что в таблице `Payment` больше записей в сравнении с другими 
таблицами. Мы сгенерировали большое количество платежей в целях тестирования, однако это близко к действительному соотношению данных, 
так как платежей обычно гораздо больше участников.

Оставшиеся части транзакции можно условно разделить на операции пересчета баланса и обновления значений таблиц. Пересчет баланса занимает **3% * 4  = 12%** 
для таблицы `PaymentParticipant` и **3% * 2 = 6%** для таблицы `Project`. Обновление записей в таблицах занимает **14% * 4 = 56%** для таблицы `PaymentParticipant` 
и **9% * 2 = 18%** для таблицы `Project`. Планы для каждой из этих операций  можно посмотреть в папке `plans/` в соответсвующих папках  `calc/` и `update/`. 
Стоит отметить, что самой затратной операцей при расчете баланса является  вставка кластерного индекса (38%), к тому же данная операция производится дважды: 
до и после перерасчета. А для операции обновления значений таблиц самой объемной по ресурсам операцией является обновление кластерного индекса 
(24% - для таблицы `PaymentParticipant`, 61% - для таблицы `Project`).

## Сценарии оптимизации
В рамках пункта 2 задания мы вводим две роли (оператор и бухгалтер-аналитик) и используем их для оптимизации операций вставки и обновления значений. 

Для оптимизации используются отложенные расчеты, тем самым сокращаются затраченные ресурсы операции обновления, а операция вставки оптимизируется за счет 
отсутствия операции перерасчета баланса в ней. 

Можно рассмотреть 2 варианта отложенных расчетов:
1. расчет по мере необходимости и предоставление актуальной информации бухгалтеру-аналитику.
2. расчет по мере накопления или с определенным периодом времени расчета.

Также можно рассмотреть два варианта учета платежей: 

**Создание нового поля в таблице `Payment`, хранящего состояние обработки платежа (платеж учтен или нет).** \
Создание нового поля в рамках данной задачи требует мало ресурсов, так как оно имеет булево значение, но при расчете баланса нам потребуется 
фильтрация по участнику платежа и по значению данного поля. Для оптимизации времени запроса можно создать индеск для нового поля. При запросе баланса 
бухгалтером-аналитиком будет производиться фильтрация по новому полю и по полям `Payer` и `Payee`.

**Создание новой таблицы для хранения необработанных платежей.**\
Еще одним вариантом для учета новых платежей может послужить таблица для их учета. При добавлении платежа он будет дублироваться в новую таблицу. 
В таком случае нет необходимости фильтрации по таблице со всеми платежами для выделения из них новых.

## Недостатки предложенных вариантов
Несмотря на сокращение расчетов во время вставки новых платежей, для дальнейшего проведения этих расчетов необходимо производить операции фильтрации. 
При расчете по мере необходимости и создании нового поля внутри таблицы `Payment` фильтрация будет происходить по трем полям. В случае, когда используется 
новая таблица, фильтрация происходит по двум полям, однако при вставке платежа мы дублируем его в две разные таблицы. Наименьшее количество фильтраций 
производится при расчете по мере накопления, но большим недостатком в данном случае является вероятность неактуальности информации о балансах.

